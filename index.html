<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countdown to Bali</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- 1. Reset and Base Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent scrolling */
        }

        body {
            font-family: 'Poppins', sans-serif;
            color: #ffffff;
            display: grid;
            place-items: center;
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #0f2027, #2c5364);
            transition: background 2.5s linear; 
        }

        /* --- 2. Day/Night Cycle Container --- */
        #celestial-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1; /* BEHIND everything */
            pointer-events: none;
        }
        
        #sun, #moon {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: all 1s linear; 
            transform: translate(-50%, -50%);
            opacity: 0;
        }
        
        #sun {
            background: #FFD700;
            box-shadow: 0 0 40px #FFD700, 0 0 60px #FFD700;
        }
        
        #moon {
            background: #E6E6E6;
            box-shadow: 0 0 20px #E6E6E6, 0 0 30px #E6E6E6;
        }
        
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            opacity: 0; 
            animation: twinkle 5s infinite ease-in-out;
            transition: opacity 2s ease-in-out; 
            z-index: 1; 
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 1; }
        }

        /* --- 3. Game Container --- */
        #game-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 3; /* IN FRONT of countdown */
            cursor: none; /* Hide cursor, player follows touch/mouse */
            -webkit-tap-highlight-color: transparent; /* Disable tap flash on mobile */
        }
        
        .game-object {
            position: absolute;
            transform: translate(-50%, -50%); /* Center emoji */
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: transform 0.1s ease-out;
            pointer-events: none; /* Player/bullets don't block controls */
        }

        .player {
            z-index: 10;
            filter: drop-shadow(0 0 8px #fff);
            font-size: 3rem;
        }

        .bullet {
            z-index: 9;
            font-size: 1.5rem;
        }
        
        .enemy {
            z-index: 8;
            filter: drop-shadow(0 0 5px #f00);
        }

        .enemy-bullet {
            z-index: 7;
            font-size: 1rem;
            filter: drop-shadow(0 0 5px #f87171);
        }

        .power-up {
            z-index: 11;
            font-size: 2rem;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); filter: drop-shadow(0 0 8px #0f0); }
            50% { transform: translate(-50%, -50%) scale(1.2); filter: drop-shadow(0 0 15px #0f0); }
        }


        /* --- 4. Main Content Container --- */
        .container {
            max-width: 800px;
            width: 100%;
            position: relative;
            z-index: 2; /* BEHIND game */
            pointer-events: none; /* Allow game clicks to go through */
        }

        h1, p { text-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        h1 { font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; }
        p { font-size: 1.1rem; font-weight: 300; margin-bottom: 2rem; }

        /* --- 5. Countdown Timer Styles --- */
        .countdown-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
        }

        .time-box {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem 2rem;
            min-width: 140px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .number { display: block; font-size: 3.5rem; font-weight: 600; }
        .label { font-size: 0.9rem; font-weight: 300; text-transform: uppercase; }
        
        /* --- 6. Expiry Message --- */
        #expiry-message { font-size: 2.5rem; font-weight: 700; color: #4ade80; }

        /* --- 7. Game UI (Score, Messages) --- */
        #game-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100; /* On top of game */
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 1.2rem; /* Adjusted for more info */
            font-weight: 600;
            text-align: left;
            line-height: 1.6;
        }

        #game-notification-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translate(-50%, -200%); 
            z-index: 101; 
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: 600;
            pointer-events: none; 
            opacity: 0;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }

        #game-notification-toast.active {
            transform: translate(-50%, 0); 
            opacity: 1;
        }

        #game-over-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 99; 
            display: none; 
            place-items: center;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            text-align: center;
        }
        
        #game-over-message {
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            text-align: center;
            line-height: 1.4;
        }
        
        #restart-btn {
            font-family: 'Poppins', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            padding: 12px 25px;
            border-radius: 8px;
            border: none;
            background: #fff;
            color: #333;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        #restart-btn:hover {
            transform: scale(1.05);
        }

        /* --- 8. Version Label --- */
        #version-label {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 98;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
        }


        /* --- 9. Responsive Design --- */
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            p { font-size: 1rem; }
            .countdown-container { gap: 1rem; }
            .time-box { min-width: 100px; padding: 1rem 1.2rem; }
            .number { font-size: 2.5rem; }
            .label { font-size: 0.75rem; }
            #sun, #moon { width: 30px; height: 30px; }

            .game-object { font-size: 2rem; }
            .player { font-size: 2.5rem; }
            .power-up { font-size: 1.8rem; }
            
            #game-ui { font-size: 1rem; padding: 8px 15px; }
            #game-over-message { font-size: 1.8rem; }
            #game-notification-toast { font-size: 1.2rem; }
        }
        
    </style>
</head>
<body>

    <div id="celestial-container">
        <div id="sun"></div>
        <div id="moon"></div>
        <!-- Static stars will be added here by JS -->
    </div>
    
    <div id="game-container">
        <!-- Player, enemies, bullets added by JS -->
    </div>
    
    <div id="game-ui">
        <span>Score: </span><span id="score-display">0</span><br>
        <span>Wave: </span><span id="wave-display">1</span><br>
        <span>Lives: </span><span id="lives-display">3</span><br>
        <span>Time: </span><span id="time-display">0s</span>
    </div>
    
    <div id="game-notification-toast"></div>
    
    <div id="game-over-overlay">
        <h2 id="game-over-message">Game Over!</h2>
        <button id="restart-btn">Restart Game</button>
    </div>

    <main class="container">
        <h1>Countdown to Bali</h1>
        <p>Time remaining until December 22nd, 11:55 AM (CET)</p>

        <div class="countdown-container" id="countdown-container">
            <div class="time-box">
                <span class="number" id="days">00</span>
                <span class="label">Days</span>
            </div>
            <div class="time-box">
                <span class="number" id="hours">00</span>
                <span class="label">Hours</span>
            </div>
            <div class="time-box">
                <span class="number" id="minutes">00</span>
                <span class="label">Minutes</span>
            </div>
            <div class="time-box">
                <span class="number" id="seconds">00</span>
                <span class="label">Seconds</span>
            </div>
        </div>
        
        <div id="expiry-message" style="display: none;">
            We've arrived! 🥳
        </div>
        
    </main>

    <div id="version-label">Version 2.2</div>

    <script>
        // --- 1. Set the Target Date ---
        const currentYear = new Date().getFullYear();
        let targetDate = new Date(`2025-12-22T11:55:00+01:00`); 
        if (targetDate - new Date() < 0) {
            targetDate = new Date(`${currentYear + 1}-12-22T11:55:00+01:00`); 
        }

        // --- 2. Get DOM Elements ---
        const daysEl = document.getElementById('days');
        const hoursEl = document.getElementById('hours');
        const minutesEl = document.getElementById('minutes');
        const secondsEl = document.getElementById('seconds');
        const countdownContainer = document.getElementById('countdown-container');
        const expiryMessage = document.getElementById('expiry-message');
        const bodyEl = document.body;
        const sunEl = document.getElementById('sun');
        const moonEl = document.getElementById('moon');
        const celestialContainer = document.getElementById('celestial-container'); 

        // --- 3. Day/Night Cycle Logic ---
        const skyColors = {
            midnight: { top: 'rgb(0, 5, 20)', bottom: 'rgb(0, 0, 0)' },
            sunrise:  { top: 'rgb(135, 206, 250)', bottom: 'rgb(255, 170, 80)' },
            noon:     { top: 'rgb(30, 144, 255)', bottom: 'rgb(135, 206, 250)' },
            sunset:   { top: 'rgb(255, 140, 0)', bottom: 'rgb(50, 0, 70)' }
        };
        function interpolateColor(c1, c2, p) {
            const [r1, g1, b1] = c1.match(/\d+/g).map(Number);
            const [r2, g2, b2] = c2.match(/\d+/g).map(Number);
            return `rgb(${Math.round(r1 + (r2 - r1) * p)}, ${Math.round(g1 + (g2 - g1) * p)}, ${Math.round(b1 + (b2 - b1) * p)})`;
        }
        function updateSky(totalMinutes) {
            let c1, c2, p;
            if (totalMinutes < 360) { p = totalMinutes / 360; c1 = skyColors.midnight; c2 = skyColors.sunrise; }
            else if (totalMinutes < 720) { p = (totalMinutes - 360) / 360; c1 = skyColors.sunrise; c2 = skyColors.noon; }
            else if (totalMinutes < 1080) { p = (totalMinutes - 720) / 360; c1 = skyColors.noon; c2 = skyColors.sunset; }
            else { p = (totalMinutes - 1080) / 360; c1 = skyColors.sunset; c2 = skyColors.midnight; }
            bodyEl.style.background = `linear-gradient(to bottom, ${interpolateColor(c1.top, c2.top, p)}, ${interpolateColor(c1.bottom, c2.bottom, p)})`;
        }
        function updateCelestialBodies(totalMinutes) {
            const isDay = totalMinutes >= 360 && totalMinutes < 1080;
            let percent = isDay ? (totalMinutes - 360) / 720 : (totalMinutes >= 1080 ? totalMinutes - 1080 : totalMinutes + 360) / 720;
            const angle = (1 - percent) * Math.PI;
            const x = 50 + 50 * Math.cos(angle); 
            const y = 100 - 85 * Math.sin(angle);
            const el = isDay ? sunEl : moonEl;
            const otherEl = isDay ? moonEl : sunEl;
            el.style.left = x + 'vw'; el.style.top = y + 'vh'; el.style.opacity = '1'; otherEl.style.opacity = '0';
        }

        // --- 4. Main Countdown Update Function ---
        let mainCountdownTimer;
        function updateCountdown() {
            const now = new Date();
            const diff = targetDate - now;
            if (diff <= 0) {
                clearInterval(mainCountdownTimer);
                countdownContainer.style.display = 'none';
                expiryMessage.style.display = 'block';
                bodyEl.style.background = `linear-gradient(120deg, #89f7fe, #fdfc47)`;
                stopGame(); // Stop the game if countdown finishes
                toggleStars(false); 
                return;
            }
            daysEl.innerText = Math.floor(diff / 864e5).toString().padStart(2, '0');
            hoursEl.innerText = Math.floor((diff % 864e5) / 36e5).toString().padStart(2, '0');
            minutesEl.innerText = Math.floor((diff % 36e5) / 6e4).toString().padStart(2, '0');
            secondsEl.innerText = Math.floor((diff % 6e4) / 1000).toString().padStart(2, '0');
            
            const totalMinutes = now.getHours() * 60 + now.getMinutes();
            updateSky(totalMinutes);
            updateCelestialBodies(totalMinutes);
            const isDaytime = totalMinutes >= 360 && totalMinutes < 1080;
            toggleStars(!isDaytime);
        }

        // --- 5. Static Star Logic ---
        let stars = [];
        const numStars = 100;
        function createStars() {
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + 'vw';
                star.style.top = Math.random() * 100 + 'vh';
                const size = Math.random() * 2 + 1;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.animationDelay = `${Math.random() * 5}s`;
                celestialContainer.appendChild(star);
                stars.push(star);
            }
        }
        function toggleStars(show) {
            setTimeout(() => {
                stars.forEach(star => {
                    star.style.opacity = show ? '1' : '0';
                });
            }, 0);
        }

        // --- 6. Game Logic ---

        // --- 6a. Game DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const livesDisplay = document.getElementById('lives-display');
        const timeDisplay = document.getElementById('time-display');
        const notificationToast = document.getElementById('game-notification-toast');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverMessage = document.getElementById('game-over-message');
        const restartBtn = document.getElementById('restart-btn');

        // --- 6b. Game State & Config ---
        let player = {};
        let gameState = {};
        let gameTimers = {};
        const allEnemies = ['👾', '👻', '👽', '🎃', '🤖', '💀', '👹', '👺', '🤡', '🦇', '🕷️', '🦂', '🐍'];
        const allPowerUps = [
            { id: 'TRIPLE_SHOT', icon: '🔱', name: 'Triple Shot' },
            { id: 'RAPID_FIRE', icon: '🔥', name: 'Rapid Fire' },
            { id: 'SHIELD', icon: '🛡️', name: 'Shield' },
            { id: 'BIG_BANANAS', icon: '💥', name: 'Big Bananas' },
            { id: 'PIERCE_SHOT', icon: '💎', name: 'Pierce Shot' },
            { id: 'SIDE_SHOTS', icon: '↔️', name: 'Side Shots' },
            { id: 'LIFE_UP', icon: '❤️', name: 'Extra Life' },
            { id: 'NUKE', icon: '💣', name: 'Nuke' },
            { id: 'SLOW_MO', icon: '⏳', name: 'Slow Mo' },
            { id: 'COIN_BONUS', icon: '💰', name: 'Coin Bonus' },
        ];

        // --- 6c. Utility Functions ---
        function pxToVw(px) { return (px / window.innerWidth) * 100; }
        function pxToVh(px) { return (px / window.innerHeight) * 100; }
        function rand(min, max) { return Math.random() * (max - min) + min; }
        
        function showNotification(message, duration = 2000) {
            notificationToast.innerText = message;
            notificationToast.classList.add('active');
            setTimeout(() => {
                notificationToast.classList.remove('active');
            }, duration);
        }

        function isColliding(objA, objB) {
            // Simple circular collision detection
            const dx = objA.x - objB.x;
            const dy = (objA.y - objB.y) * 1.5; // Account for vh/vw difference
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (objA.size + objB.size) / 2;
        }

        // --- 6d. Game Setup ---
        function initGame() {
            // Player movement listeners
            gameContainer.addEventListener('mousemove', handlePlayerMove);
            gameContainer.addEventListener('touchmove', handlePlayerMove, { passive: false });
            // Restart listener
            restartBtn.addEventListener('click', startGame);
            
            createStars();
            startGame();
        }

        function startGame() {
            // Clear all old game objects
            gameState.enemies?.forEach(e => e.el.remove());
            gameState.bullets?.forEach(b => b.el.remove());
            gameState.enemyBullets?.forEach(b => b.el.remove());
            gameState.powerUps?.forEach(p => p.el.remove());
            player.el?.remove();
            
            // Clear all game intervals
            clearInterval(gameTimers.spawnInterval);
            clearInterval(gameTimers.waveInterval);
            clearInterval(gameTimers.powerUpInterval);
            clearInterval(gameTimers.survivalTimer);
            cancelAnimationFrame(gameTimers.gameLoopId);
            
            // Reset game state
            gameState = {
                isRunning: true,
                score: 0,
                wave: 1,
                lives: 3,
                survivalTime: 0,
                isSlowMo: false,
                enemies: [],
                bullets: [],
                enemyBullets: [],
                powerUps: [],
                maxEnemies: 5,
                enemySpawnRate: 1500, // ms
            };

            // Reset player
            player = {
                x: 50, // vw
                y: 85, // vh
                size: 4, // for collision
                el: null,
                shootInterval: null,
                lastShotTime: 0,
                powerUp: null,
                powerUpTimer: null,
                hasShield: false,
                shieldEl: null,
            };

            createPlayer();
            startShooting();

            // Hide game over screen
            gameOverOverlay.style.display = 'none';
            updateUI();

            // Start game timers
            gameTimers.waveInterval = setInterval(increaseWave, 10000); // New wave every 10s
            gameTimers.spawnInterval = setInterval(spawnEnemy, gameState.enemySpawnRate);
            gameTimers.powerUpInterval = setInterval(spawnPowerUp, 15000); // Power-up every 15s
            gameTimers.survivalTimer = setInterval(() => {
                gameState.survivalTime++;
                updateUI();
            }, 1000);

            // Start the main game loop
            gameTimers.gameLoopId = requestAnimationFrame(gameLoop);
            
            showNotification('Game Started!', 1500);
        }

        function stopGame() {
            gameState.isRunning = false;
            clearInterval(gameTimers.spawnInterval);
            clearInterval(gameTimers.waveInterval);
            clearInterval(gameTimers.powerUpInterval);
            clearInterval(gameTimers.survivalTimer);
            clearInterval(player.shootInterval);
            cancelAnimationFrame(gameTimers.gameLoopId);
        }

        function gameOver() {
            stopGame();
            gameOverMessage.innerHTML = `Game Over!<br>Score: ${gameState.score}<br>Time: ${gameState.survivalTime}s`;
            gameOverOverlay.style.display = 'grid';
            
            // Player explosion effect
            if (player.el) {
                player.el.innerHTML = '💥';
                player.el.style.transform += ' scale(2)';
            }
        }

        function updateUI() {
            scoreDisplay.innerText = gameState.score;
            waveDisplay.innerText = gameState.wave;
            livesDisplay.innerText = '❤️'.repeat(gameState.lives);
            timeDisplay.innerText = `${gameState.survivalTime}s`;
        }

        // --- 6e. Player Logic ---
        function createPlayer() {
            player.el = document.createElement('div');
            player.el.className = 'game-object player';
            player.el.innerHTML = '🐒';
            gameContainer.appendChild(player.el);
            updatePlayerPosition();
        }

        function handlePlayerMove(e) {
            if (!gameState.isRunning) return;
            if (e.type.includes('touch')) e.preventDefault(); // Prevent screen scrolling

            let clientX, clientY;
            if (e.type.includes('touch')) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            player.x = Math.max(5, Math.min(95, pxToVw(clientX))); // 5% from edges
            player.y = Math.max(10, Math.min(95, pxToVh(clientY))); // 10% top, 5% bottom
        }
        
        function updatePlayerPosition() {
            if (!player.el) return;
            player.el.style.left = `${player.x}vw`;
            player.el.style.top = `${player.y}vh`;
        }

        function startShooting() {
            clearInterval(player.shootInterval);
            let shootRate = (player.powerUp === 'RAPID_FIRE') ? 100 : 250; // ms
            
            player.shootInterval = setInterval(() => {
                if (gameState.isRunning) createBullet();
            }, shootRate);
        }

        function createBullet() {
            const now = Date.now();
            if (now - player.lastShotTime < 50) return; // Anti-spam for single shots
            player.lastShotTime = now;

            let bulletsToCreate = [];
            let baseBullet = { x: player.x, y: player.y - 3, dy: -2, piercing: false, size: 1.5 };

            if (player.powerUp === 'BIG_BANANAS') baseBullet.size = 3;
            if (player.powerUp === 'PIERCE_SHOT') baseBullet.piercing = true;

            bulletsToCreate.push({ ...baseBullet });

            if (player.powerUp === 'TRIPLE_SHOT') {
                bulletsToCreate.push({ ...baseBullet, x: player.x - 3, dx: -0.3 });
                bulletsToCreate.push({ ...baseBullet, x: player.x + 3, dx: 0.3 });
            }
            if (player.powerUp === 'SIDE_SHOTS') {
                bulletsToCreate.push({ ...baseBullet, dx: -1.5, dy: -0.5 });
                bulletsToCreate.push({ ...baseBullet, dx: 1.5, dy: -0.5 });
            }

            bulletsToCreate.forEach(bData => {
                const el = document.createElement('div');
                el.className = 'game-object bullet';
                el.innerHTML = '🍌';
                el.style.left = `${bData.x}vw`;
                el.style.top = `${bData.y}vh`;
                el.style.fontSize = `${bData.size}rem`;
                if (bData.piercing) el.style.filter = 'drop-shadow(0 0 5px #00ffff)';

                let bullet = {
                    el: el,
                    x: bData.x, y: bData.y,
                    dx: bData.dx || 0,
                    dy: bData.dy || -2,
                    piercing: bData.piercing || false,
                    size: bData.size,
                };
                gameState.bullets.push(bullet);
                gameContainer.appendChild(el);
            });
        }

        function updateBullets() {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                let b = gameState.bullets[i];
                b.x += b.dx;
                b.y += b.dy;
                b.el.style.left = `${b.x}vw`;
                b.el.style.top = `${b.y}vh`;

                if (b.y < -5) { // Remove if off-screen (top)
                    b.el.remove();
                    gameState.bullets.splice(i, 1);
                }
            }
        }
        
        function playerHit() {
            if (player.hasShield) {
                player.hasShield = false;
                player.shieldEl.remove();
                player.shieldEl = null;
                showNotification('Shield lost!', 1000);
                return;
            }

            gameState.lives--;
            updateUI();
            
            if (player.el) { // Flash player red
                player.el.style.filter = 'drop-shadow(0 0 10px #f00) grayscale(1)';
                setTimeout(() => {
                    if (player.el) player.el.style.filter = 'drop-shadow(0 0 8px #fff)';
                }, 200);
            }

            if (gameState.lives <= 0) {
                gameOver();
            } else {
                showNotification('Ouch!', 1000);
            }
        }


        // --- 6f. Wave & Difficulty Logic ---
        function increaseWave() {
            if (!gameState.isRunning) return;

            gameState.wave++;
            showNotification(`Wave ${gameState.wave}!`, 1500);
            updateUI();

            // Increase difficulty
            gameState.maxEnemies = Math.min(30, 5 + gameState.wave); // Max 30 enemies
            let newSpawnRate = Math.max(200, 1500 - (gameState.wave * 50)); // Min 200ms spawn
            
            if (gameState.isSlowMo) {
                newSpawnRate *= 2; // Keep it slow if slow-mo is active
            }
            gameState.enemySpawnRate = newSpawnRate;

            // Reset spawn interval with new rate
            clearInterval(gameTimers.spawnInterval);
            gameTimers.spawnInterval = setInterval(spawnEnemy, gameState.enemySpawnRate);
        }

        // --- 6g. Enemy Logic ---
        function spawnEnemy() {
            if (!gameState.isRunning || gameState.enemies.length >= gameState.maxEnemies) {
                return;
            }

            const el = document.createElement('div');
            el.className = 'game-object enemy';
            el.innerHTML = allEnemies[Math.floor(Math.random() * allEnemies.length)];
            
            const sizeVw = rand(2.5, 4 + gameState.wave * 0.1);
            const health = Math.max(1, Math.floor(sizeVw / 2));
            
            let movementType = 'drift';
            if (gameState.wave > 3 && Math.random() > 0.5) movementType = 'zig-zag';
            if (gameState.wave > 7 && Math.random() > 0.7) movementType = 'swoop';
            
            let shoots = false;
            if (gameState.wave > 4 && Math.random() > (0.8 - gameState.wave * 0.01)) {
                shoots = true;
            }

            let enemy = {
                el: el,
                x: rand(10, 90), // vw
                y: -10, // vh
                dx: rand(-0.2, 0.2),
                dy: rand(0.2, 0.5 + gameState.wave * 0.05) * (gameState.isSlowMo ? 0.5 : 1),
                size: sizeVw,
                health: health,
                maxHealth: health,
                movement: movementType,
                moveCounter: 0,
                shoots: shoots,
                shootCooldown: rand(2000, 5000),
                lastShot: Date.now(),
            };
            
            el.style.left = `${enemy.x}vw`;
            el.style.top = `${enemy.y}vh`;
            el.style.fontSize = `${sizeVw / 1.5}rem`; // Visual size
            
            gameState.enemies.push(enemy);
            gameContainer.appendChild(el);
        }

        function updateEnemies() {
            const now = Date.now();
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                let e = gameState.enemies[i];
                let speedMultiplier = gameState.isSlowMo ? 0.5 : 1;
                
                // Base movement
                e.y += e.dy * speedMultiplier;
                e.x += e.dx * speedMultiplier;
                e.moveCounter++;

                // Special movements
                if (e.movement === 'zig-zag') {
                    e.x += Math.sin(e.moveCounter / 30) * 0.5 * speedMultiplier;
                } else if (e.movement === 'swoop') {
                    e.dy += 0.01 * speedMultiplier; // Accelerate
                }
                
                // Wall bouncing
                if (e.x < 5 || e.x > 95) e.dx *= -1;

                // Update element position
                e.el.style.left = `${e.x}vw`;
                e.el.style.top = `${e.y}vh`;
                
                // Enemy shooting
                if (e.shoots && now - e.lastShot > e.shootCooldown) {
                    createEnemyBullet(e);
                    e.lastShot = now;
                    e.shootCooldown = rand(3000, 6000) / (1 + gameState.wave * 0.1); // Shoot faster at high waves
                }

                // Remove if off-screen (bottom)
                if (e.y > 110) {
                    e.el.remove();
                    gameState.enemies.splice(i, 1);
                    if (gameState.isRunning) playerHit(); // Player takes damage if enemy gets past
                }
            }
        }
        
        function createEnemyBullet(enemy) {
            const el = document.createElement('div');
            el.className = 'game-object enemy-bullet';
            el.innerHTML = '🔥';
            
            let bullet = {
                el: el,
                x: enemy.x,
                y: enemy.y,
                dx: 0,
                dy: 2 * (gameState.isSlowMo ? 0.5 : 1),
                size: 1.5,
            };

            el.style.left = `${bullet.x}vw`;
            el.style.top = `${bullet.y}vh`;

            gameState.enemyBullets.push(bullet);
            gameContainer.appendChild(el);
        }
        
        function updateEnemyBullets() {
             for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                let b = gameState.enemyBullets[i];
                let speedMultiplier = gameState.isSlowMo ? 0.5 : 1;
                
                b.x += b.dx * speedMultiplier;
                b.y += b.dy * speedMultiplier;
                b.el.style.left = `${b.x}vw`;
                b.el.style.top = `${b.y}vh`;

                // Remove if off-screen (bottom)
                if (b.y > 105) {
                    b.el.remove();
                    gameState.enemyBullets.splice(i, 1);
                }
            }
        }
        
        function damageEnemy(enemy, bullet, bulletIndex, enemyIndex) {
            // Hit effect
            enemy.el.style.opacity = '0.5';
            setTimeout(() => {
                if (enemy.el) enemy.el.style.opacity = '1';
            }, 100);

            // Remove bullet (unless piercing)
            if (!bullet.piercing) {
                bullet.el.remove();
                gameState.bullets.splice(bulletIndex, 1);
            }

            enemy.health--;
            
            if (enemy.health <= 0) {
                // Kill enemy
                enemy.el.remove();
                gameState.enemies.splice(enemyIndex, 1);
                gameState.score += 1; // 1 point per kill
                updateUI();
            } else {
                // Update health bar (visual tint)
                const healthPercent = enemy.health / enemy.maxHealth;
                enemy.el.style.filter = `drop-shadow(0 0 5px #f00) opacity(${0.5 + healthPercent * 0.5})`;
            }
        }

        // --- 6h. Power-Up Logic ---
        function spawnPowerUp() {
            if (!gameState.isRunning) return;
            
            const pInfo = allPowerUps[Math.floor(Math.random() * allPowerUps.length)];
            const el = document.createElement('div');
            el.className = 'game-object power-up';
            el.innerHTML = pInfo.icon;
            
            let powerUp = {
                el: el,
                id: pInfo.id,
                name: pInfo.name,
                x: rand(10, 90),
                y: -10,
                dy: 0.5 * (gameState.isSlowMo ? 0.5 : 1),
                size: 3,
            };

            el.style.left = `${powerUp.x}vw`;
            el.style.top = `${powerUp.y}vh`;
            
            gameState.powerUps.push(powerUp);
            gameContainer.appendChild(el);
        }

        function updatePowerUps() {
            for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
                let p = gameState.powerUps[i];
                p.y += p.dy * (gameState.isSlowMo ? 0.5 : 1);
                p.el.style.top = `${p.y}vh`;
                
                if (p.y > 105) { // Remove if off-screen
                    p.el.remove();
                    gameState.powerUps.splice(i, 1);
                }
            }
        }

        function collectPowerUp(powerUp, index) {
            powerUp.el.remove();
            gameState.powerUps.splice(index, 1);
            showNotification(powerUp.name, 2000);
            
            // Clear any existing power-up timers/effects
            clearTimeout(player.powerUpTimer);
            if (player.powerUp === 'RAPID_FIRE') startShooting(); // Reset to normal speed
            if (player.powerUp === 'SLOW_MO') setSlowMo(false);
            player.powerUp = powerUp.id;

            // Activate new power-up
            switch (powerUp.id) {
                case 'LIFE_UP':
                    gameState.lives++;
                    updateUI();
                    player.powerUp = null; // Instant effect
                    break;
                case 'NUKE':
                    gameState.enemies.forEach(e => {
                        e.el.remove();
                        gameState.score += 1;
                    });
                    gameState.enemies = [];
                    updateUI();
                    player.powerUp = null; // Instant effect
                    break;
                case 'COIN_BONUS':
                    gameState.score += 50;
                    updateUI();
                    player.powerUp = null; // Instant effect
                    break;
                case 'SHIELD':
                    if (!player.hasShield) {
                        player.hasShield = true;
                        player.shieldEl = document.createElement('div');
                        player.shieldEl.style.cssText = `
                            position: absolute; border: 3px solid #00ffff;
                            width: 60px; height: 60px; border-radius: 50%;
                            left: 50%; top: 50%; transform: translate(-50%, -50%);
                            opacity: 0.7; animation: spin 4s linear infinite;
                        `;
                        player.el.appendChild(player.shieldEl);
                    }
                    player.powerUp = null; // Persistent until hit
                    break;
                case 'RAPID_FIRE':
                    startShooting(); // Restart with new rate
                    player.powerUpTimer = setTimeout(endPowerUp, 8000);
                    break;
                case 'SLOW_MO':
                    setSlowMo(true);
                    player.powerUpTimer = setTimeout(endPowerUp, 8000);
                    break;
                default:
                    // For TRIPLE_SHOT, BIG_BANANAS, PIERCE_SHOT, SIDE_SHOTS
                    player.powerUpTimer = setTimeout(endPowerUp, 10000);
            }
        }
        
        function endPowerUp() {
            if (!player.powerUp) return;
            
            showNotification(`${allPowerUps.find(p => p.id === player.powerUp).name} ended.`, 1500);
            
            if (player.powerUp === 'RAPID_FIRE') startShooting(); // Reset to normal
            if (player.powerUp === 'SLOW_MO') setSlowMo(false);

            player.powerUp = null;
        }

        function setSlowMo(active) {
            gameState.isSlowMo = active;
            // Re-calculate spawn rate
            let newSpawnRate = Math.max(200, 1500 - (gameState.wave * 50));
            if (active) newSpawnRate *= 2;
            gameState.enemySpawnRate = newSpawnRate;
            
            clearInterval(gameTimers.spawnInterval);
            gameTimers.spawnInterval = setInterval(spawnEnemy, gameState.enemySpawnRate);
        }

        // --- 6i. Collision Detection ---
        function checkCollisions() {
            if (!gameState.isRunning) return;

            // Player Bullets vs Enemies
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    if (gameState.bullets[i] && gameState.enemies[j] && isColliding(gameState.bullets[i], gameState.enemies[j])) {
                        damageEnemy(gameState.enemies[j], gameState.bullets[i], i, j);
                        break; // Move to next bullet
                    }
                }
            }

            // Player vs Enemies
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                if (gameState.enemies[i] && isColliding(player, gameState.enemies[i])) {
                    gameState.enemies[i].el.remove();
                    gameState.enemies.splice(i, 1);
                    playerHit();
                    break; // Only one hit per frame
                }
            }

            // Player vs Enemy Bullets
            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                if (gameState.enemyBullets[i] && isColliding(player, gameState.enemyBullets[i])) {
                    gameState.enemyBullets[i].el.remove();
                    gameState.enemyBullets.splice(i, 1);
                    playerHit();
                    break; // Only one hit per frame
                }
            }
            
            // Player vs Power-Ups
             for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
                if (gameState.powerUps[i] && isColliding(player, gameState.powerUps[i])) {
                    collectPowerUp(gameState.powerUps[i], i);
                    break;
                }
            }
        }

        // --- 6j. Main Game Loop ---
        function gameLoop() {
            if (!gameState.isRunning) return;

            // Update positions
            updatePlayerPosition();
            updateBullets();
            updateEnemies();
            updateEnemyBullets();
            updatePowerUps();
            
            // Check for hits
            checkCollisions();

            // Request next frame
            gameTimers.gameLoopId = requestAnimationFrame(gameLoop);
        }


        // --- 7. Run Timers & Init ---
        mainCountdownTimer = setInterval(updateCountdown, 1000);
        updateCountdown();
        initGame();

    </script>

</body>
</html>

